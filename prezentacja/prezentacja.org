# -*- ispell-local-dictionary: "polish"; -*-
#+REVEAL_ROOT: ./reveal.js-3.3.0
#+REVEAL_THEME: white
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: ./highlight/styles/vs.css
#+REVEAL_MARGIN: 0.05
#+OPTIONS: reveal_title_slide:nil num:nil toc:nil reveal_history:t

* Kotlin na backendzie

Łukasz Jędrzejewski

* Plan

- język
- Spring
- testowanie
- Kotlin 1.1

* Kotlin?

#+ATTR_HTML: :width 200px
[[./img/kotlin.svg]]

** Wersja 1.0

Wydana 15 lutego 2016.

** Cechy

- obiektowy
- funkcyjny
- uruchamiany na JVM

* Język
** Wyrażenia (wywalić?)

#+ATTR_REVEAL: :frag (t)
- po javowemu
  #+BEGIN_SRC kotlin
    fun newOrNull(value: String?): Msisdn {
        if (value != null) {
            return Msisdn(value)
        } else {
            return null
        }
    }
  #+END_SRC
- Ale if zwraca?
  #+BEGIN_SRC kotlin
    fun newOrNull(value: String?): Msisdn {
        return if (value != null) {
            Msisdn(value)
        } else {
            null
        }
    }
  #+END_SRC

** Jawna obsługa null

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  val a: String? = null
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  a.length    // błąd kompilacji
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  val a: String = null    // błąd kompilacji
#+END_SRC

#+ATTR_REVEAL: :frag t
- funkcje także są chronione

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  fun add1(value: Int) = value + 1

  add1(null)    // błąd kompilacji
#+END_SRC

** Elvis

#+REVEAL_HTML: <code style="font-size: 250%">?:</code>

#+ATTR_REVEAL: :frag t
#+ATTR_HTML: :width 250px
[[./img/elvis.jpg]]

#+REVEAL: split

#+BEGIN_SRC kotlin
fun findUser(name: String): User?

val name = "Elvis"
val user = findUser(name)
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
val id: Long = user.id    // błąd kompilacji
val maybeId: Long? = user?.id
val id: Long = user?.id ?: throw UserNotFoundException()
val id: Long = user?.id ?: return log.warn("User: $name not found")
#+END_SRC

** Sprytne rzutowanie

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
fun addMaybe1(value: Any?) =
        if (value is Int) value.toLong() + 1 else value
#+END_SRC

** Data klasy

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  data class Developer(val firstName: String,
                       val lastName: String,
                       val login: String)
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC java
  @AllArgsConstructor
  @Getter
  @ToString
  @EqualsAndHashCode
  @Wither
  public final class Developer {
      private final String firstName;
      private final String lastName;
      private final String login;
  }
#+END_SRC

#+REVEAL: split

#+BEGIN_SRC kotlin
  data class Developer(val firstName: String,
                       val lastName: String,
                       val login: String)
#+END_SRC

#+ATTR_REVEAL: :frag (t)
- niemutowalne (gdy nie używamy =var=) - modyfikacja przez =copy=
- destructuring bind
  #+BEGIN_SRC kotlin
  val (fn, ln) = developer
  #+END_SRC
- (ale np. na listach nie działa)

** Nazwane argumenty

- przy wywołaniu można nazwać argumenty
- dodatkowo nadać domyślne wartości
- wypada konieczność używania builderów

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  data class Developer(
          val firstName: String,
          val lastName: String,
          val login: String = toukizedLogin(firstName, lastName))
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  Developer(firstName = "Łukasz", lastName = "Jędrzejewski")
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  Developer(firstName = "Jakub",
            lastName = "Nowakowski",
            login = "kn")
#+END_SRC

*** A korzystając z biblioteki w Javie mogę tak napisać?

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  import org.springframework.security.core.userdetails.User

  User(username = username,
       password = password,
       enabled = enabled,
       accountNonExpired = true,
       credentialsNonExpired = true,
       accountNonLocked = true,
       authorities = listOf(SimpleGrantedAuthority("ROLE_REGISTERED")))
#+END_SRC

#+ATTR_REVEAL: :frag t
Nie bardzo...
** when

#+ATTR_REVEAL: :frag (t)
- =switch= na sterydach
- ochroni przed nieobsłużoną wartością w =Enum=-ie
- nie wspiera pattern matchingu
#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  when (x) {
      0, 1 -> print("x == 0 or x == 1")
      in 3..5 -> print("3 <= x <= 5")
      else -> print("otherwise")
  }
#+END_SRC

** Funkcje rozszerzające

- nie modyfikują klas
- zaimplementowane jako funkcje statyczne

** Funkcje rozszerzające na nullach

#+BEGIN_SRC kotlin
  fun Any?.toString(): String {
      return if (this == null) "null" else toString()
  }
#+END_SRC

** Kolekcje

#+ATTR_REVEAL: :frag (t)
- niemutowalne (dostępne warianty mutowalne)
- ale...
  #+BEGIN_SRC kotlin
    public operator
    fun <T> Collection<T>.plus(element: T): List<T> {
        val result = ArrayList<T>(size + 1)
        result.addAll(this)
        result.add(element)
        return result
    }
  #+END_SRC
- kompatybilne z interfejsami kolekcji z Javy

** Etykiety

#+ATTR_REVEAL: :frag t
- wyskakiwanie z lambd
  #+BEGIN_SRC kotlin
    list.map { value ->
        repeat(10) {
            val result = tryToDoSth(value)
            if (result != null) {
                return@map result
            }
        }
        null
    }
  #+END_SRC
- odwołania do zewnętrznych =this=

** StandardKt

a w nim funkcje =let=, =apply=, =with=, =run= - głównie do pracy z nullami i setterami

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
  @Bean
  open fun accessTokenConverter(): JwtAccessTokenConverter {
      return JwtAccessTokenConverter().apply {
          setSigningKey("123")
      }
  }
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
val transformedValue = value?.let {
    transformValue(it)
}
#+END_SRC

#+REVEAL: split

ale i lenistwa

#+BEGIN_SRC kotlin
userRepository.findByEmailOrThrow(email).let {
    doSthWithUser(it)
 }
#+END_SRC

zamiast
#+BEGIN_SRC kotlin
val user = userRepository.findByEmailOrThrow(email)
doSomethingWithUser(user)
#+END_SRC

** PreconditionsKt

#+BEGIN_SRC kotlin
fun require(value: Boolean): Unit
fun require(value: Boolean, lazyMessage: () -> Any): Unit

fun <T:Any> requireNotNull(value: T?): T
fun <T:Any> requireNotNull(value: T?, lazyMessage: () -> Any): T

fun check(value: Boolean): Unit
fun check(value: Boolean, lazyMessage: () -> Any): Unit

fun <T:Any> checkNotNull(value: T?): T
fun <T:Any> checkNotNull(value: T?, lazyMessage: () -> Any): T

fun error(message: Any): Nothing
#+END_SRC

** Generyki

#+ATTR_REVEAL: :frag (t)
- reklamowane jako prostsze
- zamiast =? extends= i =? super= - =out= i =in=
- ma odpowiadać producentowi i konsumentowi
- oczywiście naprawione tablice z Javy

*** Reified type parameters

#+ATTR_REVEAL: :frag t
pozwala na odwołanie się do klasy generycznego typu

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
val myServiceMock = Mockito.mock(MyServiceMock::class.java)
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
val myServiceMock: MyService = mock()
#+END_SRC

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
inline fun <reified T : Any> mock(): T =
         Mockito.mock(T::class.java)!!
#+END_SRC

** Adnotacje

TODO lub wywalić

#+ATTR_REVEAL: :frag (t)
- dziwna składnia adnotacji
  #+BEGIN_SRC kotlin
  @RequestMapping(method = arrayOf(RequestMethod.GET))
  #+END_SRC
- a zagnieżdżonych jeszcze bardziej
#+BEGIN_SRC kotlin
  @ApiResponses(ApiResponse(code = 400, message = "Bad request"),
                ApiResponse(code = 409, message = "Conflict"))
#+END_SRC
- adnotacje na property

** Oraz

- delegacja
- delegacja "pól" - wbudowane =lazy=, =observable=

TODO

* Spring
** final

#+ATTR_REVEAL: :frag t
Domyślnie klasy i metody posiadają modyfikatory =public= i =final=. Co sprawia
pewne problemy...

#+ATTR_REVEAL: :frag t
Właściwie dopóki Spring nie potrzebuje proxy (np. przez użycie =@Transactional=),
nie ma problemu. Wtedy musimy otworzyć klasę i metody poprzez =open=

*** A czy muszę o tym pamiętać?

#+ATTR_REVEAL: :frag t
Do kotlina 1.0.5 owszem

#+ATTR_REVEAL: :frag t
Od wersji 1.0.6 twórcy złamali swoje założenie i wydali plugin =kotlin-allopen=

#+ATTR_REVEAL: :frag (t)
- otwiera wszystko oznaczone wybranymi adnotacjami
- dostępna także konfiguracja z adnotacjami springowymi (=kotlin-spring=)
- a nawet kolejny plugin =no-arg=, która dodaje bezargumentowy konstruktor

** Spring 4.3

#+ATTR_REVEAL: :frag t
Trochę upraszcza

#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
@Service
class MyService(private val otherService: OtherService) {
    ...
}
#+END_SRC

#+ATTR_REVEAL: :frag t
zamiast
#+ATTR_REVEAL: :frag t
#+BEGIN_SRC kotlin
@Service
class MyService @Autowired constructor(
        private val otherService: OtherService
) {
    ...
}
#+END_SRC

** Configuration properties

#+ATTR_REVEAL: :frag t
W kotlinie wygląda brzydko

TODO - wkleić przykład z SocialConfiguration

** Jackson

#+ATTR_REVEAL: :frag t
Nie obędzie się bez dodatkowego modułu - =jackson-module-kotlin=

#+ATTR_REVEAL: :frag t
Radzi sobie klasami bez domyślnego konstruktora

** Spring 5.0

#+ATTR_REVEAL: :frag (t)
- Spring będzie rozumiał, czy typ może być nullem
  - =@Autowired=
  - =@RequestParam= i =@Header=
- =RestTemplate= wykorzysta reified...
  #+BEGIN_SRC java
  restTemplate.exchange(... new ParameterizedTypeReference<List<Foo>>() { })
  #+END_SRC
  #+BEGIN_SRC kotlin
  val result: List<Foo> = restTemplate.getForObject(url)
  #+END_SRC

* Testowanie

Można fun `should cos`() {}
Problemy z finalami.
Problemy z mockito - dlaczego potrzebna nakładka.

* W praktyce
** Null safety

TODO

Przykład.

Może Box(x) ?

Nie zapomnieć o T!

** Fluent buildery

TODO

Przykład

* Wsparcie narzędzi

Intellij automatycznie konwertuje wklejony kod Javy do Kotlina.

* Kotlin 1.1

#+ATTR_REVEAL: :frag (t)
- będzie można *dziedziczyć* z data klas, uff
- =myService::aMethod=, (aktualnie wspierane jest jedynie odniesienie do funkcji,
  np. =String::length=)
- async/await
- aliasy
- wsparcie dla Javy *8* (streamy, domyślne metody z interfejsów)

* Lokowanie produktu

#+REVEAL_HTML: <div class="fragment">

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
#+ATTR_HTML: :width 200px
[[./img/emacs.png]]

Emacs
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
#+ATTR_HTML: :width 200px
[[./img/org.png]]

Org mode
#+REVEAL_HTML: </div>

#+REVEAL_HTML: </div>

* Dziękuję!
